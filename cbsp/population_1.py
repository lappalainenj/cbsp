"""Simulations of neural population 1.

Simulations of linear- and non-linear, calcium-based, spike-timing-dependent synaptic plasticity 
of a homogeneous presynaptic population of 1000 neurons wired onto a single postsynaptic neuron.
Postsynaptic firing is generated by a poisson process.
Methods for abstracting the STDP to rate-based plasticity for large parameter spaces.

    Simple usage example:

        cbsp.set_simulation_time(2.0)
        cbsp.set_timstep(0.001)
        cbsp.population_1.linear_calcium(u=10, v=20, w0=0.5, seed=10)
"""
import multiprocessing
from itertools import product
from tqdm.auto import tqdm

import numpy as np
import numba as nb
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.colors import Normalize

import cbsp
from cbsp import utils
from cbsp.utils import feature_matrix_p1 as feature_matrix

# ---------------- STDP

@nb.jit(nopython=True)
def linear_calcium(u, v, w0, seed):
    """Integrates the spike-timing dependent synaptic strength.
    
    Args:
        u (float): presynaptic firing rate.
        v (float): postsynaptic firing rate.
        w0 (float): initial synapse strength.
        seed (int): random state.
    
    Returns:
        tuple: (w, t, (u, v, I, c))
            with 
                array: w, change of synapse strengths. Shape (#synapses, #timesteps).
                array: t, time.
                array: u, presynaptic spike trains. Shape (#synapses, #timesteps).
                array: v, postsynaptic spike train. Shape (#timesteps).
                array: I, postsynaptic current. Shape (#timesteps).
                array: c, calcium traces. Shape (#synapses, #timesteps).
    """
    # Calcium
    tau_Ca = 0.02227212
    Cpre = 0.84410
    Cpost = 1.62138
    
    # Plasticity
    thetaD = 1
    thetaP = 2.009289
    drate = 137.7586
    prate = 597.08922
    sigma = 2.8284
    tau = 520.76129
    sqrttau = np.sqrt(tau)

    # Optional, for current approximation
    tau_m = 5.e-3
    c_N = 0.4
    R = 50e6
    Iconst = c_N * tau_m / R

    np.random.seed(seed)
    time = np.linspace(0., cbsp.SIMULATION_TIME, int(cbsp.SIMULATION_TIME / cbsp.TIMESTEP) + 1)
    N = 1000
    cpre = np.zeros(N)
    cpost = np.zeros(N)
    c = np.zeros(N)
    w = np.zeros(N)
    w[:] = w0 # np.random.normal(w0, w0_std, N)

    w_rec_pop = np.zeros((N, len(time)))
    u_rec_pop = np.zeros((N, len(time)))
    v_rec = np.zeros_like(time)
    I_rec = np.zeros_like(time)
    c_rec_pop = np.zeros((N, len(time)))

    for i, t in enumerate(time):

        u_sp = utils.spike_train(N, u, cbsp.TIMESTEP)
        v_sp = utils.spike_train(1, v, cbsp.TIMESTEP)
        n = utils.standard_normal(N, cbsp.TIMESTEP)
        Hp = utils.heaviside(c-thetaP)
        Hd = utils.heaviside(c-thetaD)
        c = c - cbsp.TIMESTEP * c / tau_Ca + Cpre * u_sp + Cpost * v_sp                       
        w = w + cbsp.TIMESTEP / tau * (prate * (1 - w) * Hp - drate * w * Hd + np.sqrt(Hp+Hd) * sigma * sqrttau * n)
        w_rec_pop[:, i] = w
        u_rec_pop[:, i] = u_sp
        v_rec[i] = v_sp.item()
        I_rec[i] = Iconst * np.dot(w, u_sp)
        c_rec_pop[:, i] = c

    return w_rec_pop, time, (u_rec_pop, v_rec, I_rec, c_rec_pop)


@nb.jit(nopython=True)
def non_linear_calcium(u, v, w0, seed):
    """
    Same as ~cbsp.population_1.linear_calcium(u, v, w0, seed) for the non linear calcium model.
    """
    # Calcium
    tau_Ca = 0.01893044
    Cpre = 0.86467
    Cpost = 2.30815
    xi = (2 * (Cpost + Cpre) - Cpost) / Cpre - 1

    # Plasticity
    thetaD = 1
    thetaP = 4.99780
    drate = 111.82515
    prate = 894.23695
    sigma = 2.8284
    tau = 707.02258
    sqrttau = np.sqrt(tau)

    # Optional, for current approximation
    tau_m = 5.e-3
    c_N = 0.4
    R = 50e6
    Iconst = c_N * tau_m / R

    np.random.seed(seed)
    time = np.linspace(0., cbsp.SIMULATION_TIME, int(cbsp.SIMULATION_TIME / cbsp.TIMESTEP) + 1)
    N = 1000
    cpre = np.zeros(N)
    cpost = np.zeros(N)
    c = np.zeros(N)
    w = np.zeros(N)
    w[:] = w0
    w_rec_pop = np.zeros((N, len(time)))
    u_rec_pop = np.zeros((N, len(time)))
    v_rec = np.zeros_like(time)
    I_rec = np.zeros_like(time)
    c_rec_pop = np.zeros((N, len(time)))

    for i, t in enumerate(time):

        u_sp = utils.spike_train(N, u, cbsp.TIMESTEP)
        v_sp = utils.spike_train(1, v, cbsp.TIMESTEP)
        n = utils.standard_normal(N, cbsp.TIMESTEP)
        Hp = utils.heaviside(c-thetaP)
        Hd = utils.heaviside(c-thetaD)
        cpre = cpre - cbsp.TIMESTEP * cpre / tau_Ca + Cpre * u_sp
        cpost = cpost - cbsp.TIMESTEP * cpost / tau_Ca + Cpost * v_sp + xi * v_sp * cpre
        c = cpre + cpost
        w = w + cbsp.TIMESTEP / tau * (prate * (1 - w) * Hp - drate * w * Hd + np.sqrt(Hp+Hd) * sigma * sqrttau * n)
        w_rec_pop[:, i] = w
        u_rec_pop[:, i] = u_sp
        v_rec[i] = v_sp.item()
        I_rec[i] = Iconst * np.dot(w, u_sp)
        c_rec_pop[:, i] = c

    return w_rec_pop, time, (u_rec_pop, v_rec, I_rec, c_rec_pop)

# ---------------- RBP

def stdp2rbp_linear_calcium(*args, **kwargs):
    """Rate-based plasticity from STDP using the linear calcium model.
    
    Args:
        - same as cbsp.population_1.linear_calcium(u, v, w0, seed)

    Returns:
        float: the population average change of synapse strength at time point 0
    """
    w_rec, t, _ = linear_calcium(*args, **kwargs)
    return utils.derivative(w_rec.mean(axis=0), t)


def stdp2rbp_non_linear_calcium(*args, **kwargs):
    """Rate-based plasticity from STDP using the non linear calcium model.
    
    Same arguments as ~cbsp.population_1.non_linear_calcium(u, v, w0, seed)

    Returns:
        float: the population average change of synapse strength at time point 0
    """
    w_rec, t, _ = non_linear_calcium(*args, **kwargs)
    return utils.derivative(w_rec.mean(axis=0), t)


def main_linear_calcium(u=np.arange(0, 101),
                        v=np.arange(0, 101),
                        w=np.arange(0, 1.05, 0.05),
                        seed=np.arange(0, 100),
                        nproc=2):
    """RBP from STDP for the whole parameter space using the linear calcium model.
    
    Args:
        u (array, optional): presynaptic firing rates. Defaults to np.arange(0, 101).
        v (array, optional): postsynaptic firing rates. Defaults to np.arange(0, 101).
        w (array, optional): initial synaptic strengths. Defaults to np.arange(0, 1.05, 0.05).
        seed (array, optional): random states. Defaults to np.arange(0, 100).
        nproc (int, optional): number of processes to use. Defaults to 8.
    
    Returns:
        array: rate-based plasticity for all possible combinations of u, v, and w.
                Has shape (#random_states, u.size * v.size * w.size).
    """
    pool = multiprocessing.Pool(processes=nproc)
    results = np.zeros([seed.size, u.size*v.size*w.size])
    for i, s in enumerate(tqdm(seed, desc='Seed')):
        results[i] = np.array(pool.starmap(stdp2rbp_linear_calcium, product(u, v, w, np.array([s]))))
    return results


def main_non_linear_calcium(u=np.arange(0, 101),
                            v=np.arange(0, 101),
                            w=np.arange(0, 1.05, 0.05),
                            seed=np.arange(0, 100),
                            nproc=2):
    """
    Same as ~cbsp.population_1.main_linear_calcium(u, v, w, seed, nproc) for the non linear calcium model.
    """
    pool = multiprocessing.Pool(processes=nproc)
    results = np.zeros([seed.size, u.size*v.size*w.size])
    for i, s in enumerate(tqdm(seed, desc='Seed')):
        results[i] = np.array(pool.starmap(stdp2rbp_non_linear_calcium, product(u, v, w, np.array([s]))))
    return results


def plot_3d(u, v, w, rbp):
    """Plots the RBP in 3d.
    
    Args:
        u (array): presynaptic firing rates.
        v (array): postsynaptic firing rate.
        w (array): initial synapse strengths.
        rbp (array): rate-based plasticity for the parameter space.
                     Flat or of shape (u.size, v.size, w.size).
    
    Returns:
        tuple: figure and axis objects.
    """

    class MidpointNormalize(Normalize):
        def __init__(self, vmin=None, vmax=None, midpoint=None, clip=False):
            self.midpoint = midpoint
            Normalize.__init__(self, vmin, vmax, clip)

        def __call__(self, value, clip=None):
            x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.5, 1]
            return np.ma.masked_array(np.interp(value, x, y))

    fig = plt.figure(figsize=[10, 5])
    U, W = np.meshgrid(u, w)
    Z = rbp.reshape(len(u), len(v), len(w))[np.arange(len(u)), np.arange(len(v))]

    ax = fig.add_subplot(111, projection='3d')
    norm = MidpointNormalize(vmin=-0.1, vmax=0.4, midpoint=0)
    ax.plot_surface(X=U, Y=W, Z=Z.T, rstride=1, cstride=1, cmap=plt.cm.seismic, norm=norm, antialiased=False)
    ax.set_xlabel('$u=v$', fontsize = 10)
    ax.set_ylabel('$w$', fontsize = 10)
    ax.set_zlabel('$\dot{w}(u, v, w)$', fontsize=10)
    ax.grid(False)
    ax.view_init(11, 130)
    return fig, ax


def plot_dynamics(w, t, u, v, I, c):
    """Plots a column of the simulated dynamics.

    Args:
        w (array): change of synapse strengths. Shape (#synapses, #timesteps).
        t (array): time.
        u (array): presynaptic spike trains. Shape (#synapses, #timesteps).
        v (array): postsynaptic spike train. Shape (#timesteps).
        I (array): postsynaptic current. Shape (#timesteps).
        c (array): calcium traces. Shape (#synapses, #timesteps).

    Returns:
        tuple: fig, axes
    """

    fig = plt.figure(figsize=[4, 12])

    ax1 = plt.subplot(411)
    ax1.plot(t, utils.moving_average(t, u.mean(axis=0), width=0.100, spikes=True), label='u')
    ax1.plot(t, utils.moving_average(t, v, width=0.500, spikes=True), label='v')
    ax1.set_xticks([])
    ax1.set_ylabel('u, v in Hz')
    ax1.set_ylim(0, 100)
    ax1.set_xlim(-0.25, 5.25)
    ax1.legend()

    ax2 = plt.subplot(412)
    ax2.plot(t, utils.moving_average(t, I, width=0.025))
    ax2.set_xticks([])
    ax2.set_ylim(0, 1.1e-9)
    ax2.set_ylabel('I in A')

    ax3 = plt.subplot(413)
    ax3.plot(t, c.T[:, ::20], '0.7')
    ax3.plot(t, c[501, :])
    ax3.set_xticks([])
    ax3.set_ylabel('calcium concentration')

    ax4 = plt.subplot(414)
    utils.trace_pop_mean_with_std(t, w, fig=fig, ax=ax4, label="population")
    ax4.plot(t, w[501, :], label="individual")
    ax4.set_xlabel('time')
    ax4.set_ylabel('synaptic strength')
    ax4.legend()
    return fig, (ax1, ax2, ax3, ax4)
